#!/bin/bash

printf "\n"

# Define styled output helpers
RED="\033[1;31m"
GREEN="\033[1;32m"
BLUE="\033[1;34m"
YELLOW="\033[1;33m"
MAGENTA="\033[1;35m"
WHITE="\033[1;37m"
RESET="\033[0m"
BOLD="\033[1m"

# Dynamic horizontal line for styling
print_line() {
  local length=$1
  printf "${WHITE}%*s\n" $((length + 1)) | tr " " "="
}

# Constants
SHORT_DESC_LENGTH=120
SUCCESS_MSG="‚úÖ SUCCESS: Your commit message follows the correct format."
ERROR_MSG="‚ùå ERROR: Commit message does not follow the required format."
EMPTY_MSG="‚ùå ERROR: Commit message is empty."
TIP_MSG="üí° Tip: Use \`git commit --amend\` to modify your commit message."
MISSING_SHORT_DESC="‚ùå ERROR: Short description is missing or improperly formatted."
SHORT_DESC_LIMIT="ERROR: Short description exceeds limit characters."
INVALID_COMMIT_TYPE="‚ùå ERROR: Invalid commit type."
INVALID_COMMIT_SCOPE="‚ùå ERROR: Invalid commit scope."
INVALID_REFS_ID="‚ùå ERROR: Invalid 'Refs' line."

# Define type and scope options in arrays
TYPES=("feat" "fix" "docs" "style" "refactor" "perf" "test" "chore")
SCOPES=("Authentication" "Backend" "API" "Database")

# Generate type and scope regex dynamically (no trailing or leading spaces)
TYPE_REGEX=$(IFS=\|; echo "${TYPES[*]}")
SCOPE_REGEX=$(IFS=\|; echo "${SCOPES[*]}")

# Define regex for each part of the commit message
SHORT_DESC_REGEX="[A-Z][^\n]{1,${SHORT_DESC_LENGTH}}"         # Starts with an uppercase letter, max ${SHORT_DESC_LENGTH} characters
MULTILINE_DESC_REGEX="(\n.+)*"                                  # Optional multiline description
REFS_REGEX="Refs: #(CU-)*[a-zA-Z0-9]+"                          # Refs line with optional "CU-" prefix and alphanumeric task ID

# Combine regex for full commit message validation
COMMIT_MSG_PATTERN="^($TYPE_REGEX)\(($SCOPE_REGEX)\): $SHORT_DESC_REGEX$MULTILINE_DESC_REGEX\n*\n*$REFS_REGEX$"

# Read the commit message (file or input string)
if [ -f "$1" ]; then
  COMMIT_MSG=$(<"$1")
elif [ -n "$1" ]; then
  COMMIT_MSG="$1"
else
  echo -e "${MAGENTA}${BOLD}$EMPTY_MSG${RESET}"
  exit 1
fi

# Ensure the commit message is not empty
if [[ -z "$COMMIT_MSG" ]]; then
  print_line ${#EMPTY_MSG}
  echo -e "${MAGENTA}${BOLD}$EMPTY_MSG${RESET}"
  print_line ${#EMPTY_MSG}
  exit 1
fi

# Extract and validate short description
SHORT_DESC=$(echo "$COMMIT_MSG" | sed -n 's/^[^:]*: \(.*\)$/\1/p' | head -n 1)

# Validate short description
if [[ -z "$SHORT_DESC" ]]; then
  print_line ${#MISSING_SHORT_DESC}
  echo -e "${RED}${BOLD}$MISSING_SHORT_DESC${RESET}"
  print_line ${#MISSING_SHORT_DESC}

  exit 1
fi

# Ensure short description length is within limits
if (( ${#SHORT_DESC} > $SHORT_DESC_LENGTH )); then
  print_line ${#SHORT_DESC_LIMIT}
  echo -e "${RED}${BOLD}$SHORT_DESC_LIMIT${RESET}"
  print_line ${#SHORT_DESC_LIMIT}
  exit 1
fi

# Validate the type
TYPE=$(echo "$COMMIT_MSG" | sed -n 's/^\([a-zA-Z]*\)(.*):.*/\1/p')
if [[ ! " ${TYPES[@]} " =~ " ${TYPE} " ]]; then
  print_line ${#INVALID_COMMIT_TYPE}
  echo -e "${RED}${BOLD}$INVALID_COMMIT_TYPE${RESET}"
  print_line ${#INVALID_COMMIT_TYPE}
  exit 1
fi

# Validate the scope
SCOPE=$(echo "$COMMIT_MSG" | sed -n 's/^[a-zA-Z]*(\([a-zA-Z]*\)):.*$/\1/p')
if [[ ! " ${SCOPES[@]} " =~ " ${SCOPE} " ]]; then
  print_line ${#INVALID_COMMIT_SCOPE}
  echo -e "${RED}${BOLD}$INVALID_COMMIT_SCOPE${RESET}"
  print_line ${#INVALID_COMMIT_SCOPE}
  exit 1
fi

# Validate refs line (optional)
if [[ ! "$COMMIT_MSG" =~ $REFS_REGEX ]]; then
  print_line ${#INVALID_REFS_ID}
  echo -e "${RED}${BOLD}$INVALID_REFS_ID${RESET}"
  print_line ${#INVALID_REFS_ID}
  exit 1
fi

# Validate full commit message format using regex
if [[ "$COMMIT_MSG" =~ $COMMIT_MSG_PATTERN ]]; then
  print_line ${#SUCCESS_MSG}
  echo -e "${GREEN}${BOLD}$SUCCESS_MSG${RESET}"
  print_line ${#SUCCESS_MSG}
  exit 0
else
  # Invalid commit message
  message="Commit message requirements:"
  print_line ${#message}
  echo -e "${YELLOW}${message}${RESET}"
  print_line ${#message}
  
  # Commit message format explanation
  echo -e "${BLUE}  ‚úÖ Format: <type>(<scope>): <short description>${RESET}"
  echo -e "${BLUE}    - <type>: One of ($(IFS=\,; echo "${TYPES[*]}"))${RESET}"
  echo -e "${BLUE}    - <scope>: One of ($(IFS=\,; echo "${SCOPES[*]}"))${RESET}"
  echo -e "${BLUE}    - <description>: Starts with uppercase, max $SHORT_DESC_LENGTH chars${RESET}\n"
  echo -e "${BLUE}  Body (optional): Detailed change description (multiline supported).${RESET}\n"
  echo -e "${BLUE}  Footer (required): ${REFS_REGEX}${RESET}\n"

  # Examples
  echo -e "${MAGENTA}${BOLD}Examples:${RESET}\n"
  echo -e "${RED}  ‚ùå add user authentication feature${RESET}\n"
  echo -e "${GREEN}  ‚úÖ feat(Authentication): Add user authentication feature${RESET}"
  echo -e "${GREEN}     Implemented a secure flow.${RESET}"
  echo -e "${GREEN}     Refs: #CU-12345${RESET}\n"
  echo -e "${GREEN}  ‚úÖ fix(API): Resolve API endpoint errors${RESET}"
  echo -e "${GREEN}     Fixed timeout issues in user endpoints.${RESET}"
  echo -e "${GREEN}     Refs: #CU-67890${RESET}\n"
  echo -e "${GREEN}  ‚úÖ test(Database): Add tests for database migrations${RESET}"
  echo -e "${GREEN}     Verified integrity during schema updates.${RESET}"
  echo -e "${GREEN}     Refs: #CU-98765${RESET}\n"

  # Tip for modification
  print_line ${#TIP_MSG}
  echo -e "${YELLOW}${BOLD}$TIP_MSG${RESET}"
  print_line ${#TIP_MSG}

  printf "\n"

  # Final error message
  print_line ${#ERROR_MSG}
  echo -e "${RED}${BOLD}$ERROR_MSG${RESET}"
  print_line ${#ERROR_MSG}
  exit 1
fi