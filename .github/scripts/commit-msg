#!/bin/bash

# Check if the input is a file or a String 
if [ -f "$1" ]; then
  # If it's a file, read the commit message from the file
  COMMIT_MSG=$(<"$1")
elif [ -n "$1" ]; then
  # If it's a string, use the passed argument as the commit message
  COMMIT_MSG="$1"
else
  # If no input is provided, print an error message
  echo "‚ùå ERROR: No commit message or file provided."
  exit 1
fi

# Define the regular expression for commit message validation
# This regex ensures:
# - Type is one of the valid types (feat, fix, docs, etc.)
# - Scope allows single or multi-word phrases starting with a capital letter
# - Description starts with an uppercase letter and is ‚â§150 characters
# - Body (optional) follows a blank line and can span multiple lines
# - Footer (optional) includes `Refs:` for references
REGEX="^(feat|fix|docs|style|refactor|perf|test|chore)\(([A-Z][a-zA-Z0-9 _-]*)\): [A-Z].{0,149}(\n\n.+)?(\n\nRefs: #?[a-zA-Z0-9 _-]+)?$"

# Define styled output helpers
RED="\033[1;31m"
GREEN="\033[1;32m"
BLUE="\033[1;34m"
YELLOW="\033[1;33m"
MAGENTA="\033[1;35m"
BOLD="\033[1m"
RESET="\033[0m"
WHITE="\033[1;37m"

# Define a function for printing a dynamic horizontal line
print_line() {
  local message_length=$1
  printf "${WHITE}%*s\n" $((message_length + 1)) | tr " " "="
}

# Check if the commit message is empty
if [ -z "$COMMIT_MSG" ]; then
  print_line 39 # Adjust the number (39) if you change the error message length
  printf "${MAGENTA}${BOLD}‚ùå ERROR: Commit message is empty.${RESET}\n"
  print_line 39
  exit 1
fi

# If the commit message is valid, show success with green ‚úÖ
if echo "$COMMIT_MSG" | grep -Eq "$REGEX"; then
  message="‚úÖ SUCCESS: Your commit message follows the correct format."
  print_line ${#message}
  printf "${GREEN}${BOLD}${message}${RESET}\n"
  print_line ${#message}
else
  # If the commit message is invalid, show error with red ‚ùå (but at the end)
  message="Commit message requirements:"
  print_line ${#message}
  printf "${YELLOW}${message}${RESET}\n"
  print_line ${#message}

  # Show the detailed format description (without line separators)
  printf "\n"

  message="‚úÖ Format: <type>(<Scope>): <short description>"
  printf "${BLUE}  ${message}${RESET}\n"

  message="- <type>: feat, fix, docs, style, refactor, perf, test, chore"
  printf "${BLUE}    ${message}${RESET}\n"

  message="- <Scope>: Mandatory, allows one or more words (e.g., User Interface, Backend)"
  printf "${BLUE}    ${message}${RESET}\n"

  message="- <description>: Must start with an uppercase letter and be max 150 chars"
  printf "${BLUE}    ${message}${RESET}\n\n"

  message="Body (optional): Detailed description of the change."
  printf "${BLUE}  ${message}${RESET}\n"

  message="Footer (optional): Includes only \`Refs\` for task references in ClickUp."
  printf "${BLUE}  ${message}${RESET}\n"
  
  message="  Example: Refs: #CU-86967ku38"
  printf "${BLUE}    ${message}${RESET}\n\n"

  message="Examples:"
  printf "${MAGENTA}${BOLD}Examples:${RESET}\n"
  message="‚úÖ feat(User Interface): Add user authentication feature"
  printf "${GREEN}  ${message}${RESET}\n"
  message="  Implemented a secure authentication flow using JWT tokens."
  printf "${GREEN}    ${message}${RESET}\n"
  message="  Refs: #CU-86967ku38" # Example task ID from ClickUp
  printf "${GREEN}    ${message}${RESET}\n\n"

  # Show the tip
  message="üí° Tip: Use \`git commit --amend\` to modify your commit message."
  print_line ${#message}
  printf "${YELLOW}${BOLD}${message}${RESET}\n"
  print_line ${#message}

  printf "\n"

  # Finally, display the error message at the very end with line separators
  message="‚ùå ERROR: Commit message does not follow the required format."
  print_line ${#message}
  printf "${RED}${BOLD}${message}${RESET}\n"
  print_line ${#message}
  
  exit 1
fi